<!DOCTYPE html>
<html lang="de">
<head>
  <title>Prof. Dr. Christian Forler</title>
  <meta name="referrer" content="no-referrer">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="style-src 'self'">


  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/pure.css">
  <link rel="stylesheet" href="css/grids-responsive-min.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="icon" href="images/favicon_bht.ico" type="image/x-icon; charset=binary">
  
</head>
<body>
<div class="beuth-div">
  <a href="https://www.bht-berlin.de" target="_blank" rel="noopener noreferrer" >
    <img class="beuth-img" src="images/BHT_Logo_horizontal_Anthrazit_transparent.svg" alt="Logo der Berliner Hochschule für Technik">
  </a>
</div>

<nav class="pure-menu pure-menu-horizontal">
  <a href="index.html" class="pure-menu-heading pure-menu-link">Prof. Dr. Christian Forler</a>
  <ul class="pure-menu-list">
    <li class="pure-menu-item"><a href="abschlussarbeiten.html"
                                  class="pure-menu-link">Themen für Abschlussarbeiten</a></li>
    <li class="pure-menu-item"><a href="leitfaden.html"
                                  class="pure-menu-link">Leitfaden für Abschlussarbeiten</a></li>
     <li class="pure-menu-item"><a href="oral_examination.html"
                                  class="pure-menu-link">Leitfaden
         für mündliche Prüfungen</a></li>

     <li class="pure-menu-item"><a href="crashkurs.html" class="pure-menu-link">Programmieren</a></li>
  </ul>
</nav>
<div class="content">
  <div class="pure-g">
    <div class="pure-u-md-1">
      <div class="l-box">
        <h1>Themen für Abschlussarbeiten</h1>

        
        <h2>Abschlussarbeiten des PSE-Labors</h2>
        <p>
          Als Mitglied
          des <a href="https://labor.bht-berlin.de/pse"
                 target="_blank" rel="noopener noreferrer">PSE-Labors</a>
          betreue ich auch ausgewählte Abschlussarbeiten, die dort
          ausgeschrieben sind. Eine Übersicht gibt es <a href="https://labor.bht-berlin.de/pse/acalab-aktivitaeten-und-abschlussarbeiten/" target="_blank" rel="noopener noreferrer">hier</a>.
        </p>
        
        <h2> Abschlussarbeiten in eigener Regie </h2>

        <h3>Bachelorarbeiten</h3>

        <h4>Fuzzing</h4>

        <p>In dieser Abschlussarbeit sollen Sie mithilfe eines Fuzzers wie
          <a href="https://github.com/AFLplusplus/AFLplusplus"
          target="_blank" rel="noopener noreferrer"><code>afl++</code></a> oder einer
          Fuzzer-Bibliothek wie <a href="https://github.com/llvm-mirror/llvm/blob/master/docs/LibFuzzer.rst"
          target="_blank" rel="noopener noreferrer"><code>libFuzzer</code></a> eine oder mehrere
          Anwendungen systematisch auf Programmierfehler und
          Sicherheitslücken untersuchen.  Dabei sollen qualitative und
          quantitative Angaben über die durch das Fuzzen erreichte
          Testabdeckung gemacht werden.
        </p>
        <p>
          Diese Abschlussarbeit richtet sich insbesondere an
          Werkstudenten und Werkstudentinnen. Hier bietet sich die
          Gelegenheit, Software, die von Ihrer Firma entwickelt wird,
          auf Fehler zu untersuchen, um deren Qualität zu steigern.
        </p>
            
        
        <h4> Filmbewertungs-Aggregator</h4>
        <p>Die Abschlussarbeit beschäftigt sich mit der Entwicklung
          einer anwendungsübergreifenden Lösung zur Aggregation und
          Anzeige von Filmbewertungen von "Rotten Tomatoes" und
          "Metacritic". </p>
        
        <p>Die entwickelte Anwendung wird lokal auf einem
          Linux-Rechner laufen und die APIs von "Rotten Tomatoes" und
          "Metacritic" integrieren, um aktuelle Bewertungen für eine
          definierte Filmauswahl abzurufen. Die aggregierten
          Bewertungen werden dann über eine gut strukturierte UI zur
          Verfügung gestellt.</p>

        <p>Zusätzlich zur Bewertungsabfrage SOLL auch einen
          effizienten Caching-Mechanismus implementieren.
        </p>
        
        <p> Das Ziel ist es, eine benutzerfreundliche Anwendung zu
          entwickeln, die es ermöglicht, nahtlos auf
          Filmbewertungsdaten zuzugreifen und diese gut strukturiert
          darzustellen.</p>

        <h4>Visualisierung von Operationen auf einem  AVL-Baum</h4>
        <p>
	      Im Rahmen dieser Abschlussarbeit soll eine Anwendung erstellt
	      werden, welche die Einfüge- und Löschoperation bei einem 
	      <a href="https://de.wikipedia.org/wiki/AVL-Baum" target="_blank"
	         rel="noopener noreferrer"> AVL-Baum</a>
	      visualisiert. Im Fokus stehen hier die Einfach- und
	      Doppelrotationen. Die Anwendung soll noch die weiteren Anforderungen erfüllen
           <ul class="list">
             <li> Exportieren eines AVL-Baums in einen menschenlesbare Form.</li>
             <li> Importieren eines AVL-Baums aus einer Datei. </li>
             <li> Anzeige der einzelnen AVL-Werte. </li>
             <li> Konvertierung eines beliebigen binären Suchbaum in einen AVL-Baum.</li>
             <li> Animierte Einfach- und Doppelrotationen. </li>
             <li> Unterstützung von Bäumen mit bis zu 63 Knoten. </li>
             <li> (OPTIONAL) Gamification Aspekte. </li>
           </ul>
	  
           
           <h4> Design Entwicklung einer interaktiven Anwendung zur
             Visualisierung von Betriebsmodi in der Kryptographie.</h4>
           
        <p>In dieser Bachelorarbeit wird eine interaktive Anwendung
          entwickelt, die es Studierenden ermöglicht, die Betriebsmodi
          ECB (Electronic Codebook), CBC (Cipher Block Chaining) und
          Counter-Mode in der Kryptographie zu verstehen und zu
          visualisieren. Die Anwendung dient als lehrreiches Tool, um
          das grundlegende Konzept der verschiedenen Betriebsmodi zu
          erklären.</p >
        
        <p>Die entwickelte Anwendung bietet eine benutzerfreundliche
          Oberfläche, auf der die Studierenden die Funktionsweise der
          Betriebsmodi nachvollziehen können. Es sollen visuell die
          Verarbeitung der einzelnen Klartext- bzw. Chiffretextblöcke
          veranschaulicht werden.</p>

        <p>Ein wichtiges Feature der Anwendung ist die Möglichkeit,
          für kleine vorgegebene (2-6 Bit) Blockchiffren, entweder
          Klartexte manuell zu verschlüsseln oder Chiffretexte wieder
          manuell zu entschlüsseln. Dadurch können die Studierenden
          aktiv anhand praktischer Beispiele die Verwendung der
          verschiedenen Betriebsmodi erleben und ihr Verständnis
          vertiefen.</p>
        

        <h4>Visualisierung der Tiefensuche</h4>
        <p>
	  Im Rahmen dieser Abschlussarbeit soll eine Anwendung
	  erstellt werden, welche die
	  <a href="https://de.wikipedia.org/wiki/Tiefensuche"
	     target="_blank" rel="noopener noreferrer">
	    Tiefensuche</a> visualisiert. Und zwar soll mittels der
	    Tiefensuche ein Ausgang aus einem Labyrinth gefunden
	    werden. Folgende Features sollen implementiert werden:
	</p>
        <ul class="list">
          <li>
	    Editierend von Labyrinthen
	  </li>
	  <li>
	    Speichern und Laden von Labyrinthen.
	  </li>
	  <li>
	    Der Startpunkt und das Ziel/Ausgang soll frei wählbar sein.
	  </li>
	  <li>
	    GNU/Linux Unterstützung.
	  </li>
	</ul>
	  
 
         <h4>Anwendung zur Veranschaulichung von Sortierverfahren</h4>
         <p>
         Im Rahmen dieser Abschlussarbeit soll ein Anwendung für
         die Lehre implementiert werden. Ziel der Anwendung ist es zum
         einen den NutzerInnen Sortierverfahren verständlich zu
         erläutern und zum anderen durch Test herausfinden, ob diese
         auch verstanden wurden. Insgesamt soll die Anwendung die
         folgenden fünf Sortierverfahren abdecken.
         </p>
         <ol>
           <li> BubbleSort    </li>
           <li> InsertionSort </li>
           <li> MergeSort     </li>
           <li> HeapSort      </li>
         </ol>
         <p>
         Die einzelnen Implementierungen sollen dabei den Definitionen
         aus meinen Lehrmaterialien zu dem Modul <q> Algorithmen und
         Datenstrukturen </q> entsprechen. Daher sind sie
         eigenständig zu implementieren.

          
         Die Anwendung kann beispielsweise über einen Erklär- und
         einen Testmodus verfügen. Bei dem Erklärmodus können die
         Sortierverfahren durch Animationen (spielerisch)
         näher gebracht werden.
                 
         In dem Testmodus sollen unsortiertes Array mithilfe eines
         angegeben Sortierverfahrens sortiert werden. Dabei soll die
         NutzerInnen natürlich Feedback bekommen, ob Sie alles richtig
         gemacht haben und falls nicht soll veranschaulicht werden, wo
         es hakte.
         </p>

         <p>
           Ein wichtiger Aspekt dieser Arbeit ist selbstverständlich
           die Usability der Anwendung. Gerne kann auch die Motivation
           zur Nutzung der Anwendung mithilfe von Gamification Aspekten
           optimiert werden.

           Ich kann mir gut vorstellen, diese Anwendung in eine Art
           Spiel zu verpacken. Ein Beispiel für ein Spiel durch das
           die NutzerInnen Assembler lernen
           ist <a href="https://en.wikipedia.org/wiki/Human_Resource_Machine"
           target="_blank" rel="noopener noreferrer"> Human Resource
           Machine </a>. Wie Sie sehen ist bei dieser Arbeit der
           Kreativität keine Grenzen gesetzt.
         </p>
          
      
       
 <!--    
        <h4>Management von Identitäten mittels PGP</h4>
        <p>
          Im Rahmen dieser Bachelorarbeit soll eine Linux-Anwendung
          erstellt werden, mit deren Hilfe sich Identitäten
          (E-Mail-Adressen) mit Hilfe von PGP-Schlüsseln verwaltet
          lassen. Der Fokus liegt bei dieser Anwendung auf der
          Benutzerfreundlichkeit. Es soll einfach und intuitiv
          bedienbar sein und kein Expertenwissen von PGP und GPG
          voraussetzen.
        </p>
        <p>
          Die Anwendung muss in der Lage sein, einen bereits
          existierenden PGP-Schlüssel zu importieren. Weiterhin soll
          es in der Lage sein, einen öffentlicher PGP-Schlüssel
          mit <code>n</code> Identitäten in <code>n</code> öffentliche
          PGP-Schlüssel mit jeweils einer Identitäten zu
          zerlegen. Hierbei ist zu beachten, dass alle öffentlichen
          PGP Schlüssel einen gemeinsamen privaten Schlüssel teilen
          sollen.
        </p>
!-->


         <h4>Generierung von UML-Diagrammen</h4>
        <p>
          Im Rahmen dieser Abschlussarbeit soll eine Bibliothek
          erstellt werden die aus C++ oder Java-Klassen
          einliest und daraus ein UML-Klassendiagramm erstellt.
        </p>
        <p>
          Aufgabe ist es also das parsen von Quelldateien und die
          Generierung von Vektorgraphiken welche sich möglichst
          einfach in ein LaTeX Dokument, wie beispielsweise eine
          Abschlussarbeit, integrieren lassen sollen. Es ist wäre
          wünschenswert, falls die LaTeX-Ausgabe kompatibel zu zu dem
          CTAN-Paket <a href="https://ctan.org/pkg/uml"
          target="_blank" rel="noopener noreferrer"> UML </a> ist.
        </p>
        
        
        
        <h3>Masterarbeiten</h3>

        <h4>Vergleich des Speicherverbrauchs eigener Implementierungen von Echo-Servern bei parallelen Verbindungen</h4>
    <p>Die Masterarbeit widmet sich einem detaillierten Vergleich des
      Speicherverbrauchs von selbst erstellten Echo-Servern, die in
      verschiedenen Programmiersprachen und Frameworks implementiert sind,
      bei unterschiedlichen parallelen Verbindungen. Ein Echo-Server ist
      ein einfacher Server, der die empfangenen Daten zurücksendet, ohne
      diese zu verarbeiten. In dieser Arbeit werden eigene
      Implementierungen der Echo-Server in den folgenden
      Programmiersprachen und Frameworks erstellt und verglichen:</p>
  <ul>
    <li>C (epoll oder select)</li>
    <li>Spring Framework</li>
    <li>Express Framework</li>
    <li>Django Framework</li>
    <li>Rails Framework</li>
    <li>Laravel Framework</li>
  </ul>
  <p>Das Hauptziel der Arbeit ist es, den Speicherverbrauch jeder
  eigenen Implementierung bei 10, 100, 1.000 und 10.000 parallelen
  Verbindungen zu analysieren und zu vergleichen. Diese
  unterschiedlichen Lastszenarien ermöglichen es, die Skalierbarkeit
  und Effizienz der eigenen Echo-Server unter verschiedenen
    Belastungen zu bewerten.</p>
  
  <p>Die Masterarbeit wird eine umfangreiche Umsetzung der eigenen
  Echo-Server-Implementierungen beinhalten. Dabei werden spezifische
  Testumgebungen geschaffen, um die parallelen Verbindungen zu
  simulieren und den Speicherverbrauch präzise zu messen.</p>

   <p>Die erzielten Ergebnisse werden sorgfältig dokumentiert und in
   einer übersichtlichen Form präsentiert. Die gewonnenen Erkenntnisse
   werden wertvolle Informationen für die Entwicklergemeinschaft
   liefern, um die optimale Implementierung für
   Echo-Server-Anwendungen zu wählen. Die Arbeit wird zudem als
   wertvolle Grundlage dienen, um die Leistung und Skalierbarkeit von
   Webanwendungen zu verbessern und fundierte Entscheidungen
   hinsichtlich der Auswahl des geeigneten Frameworks zu treffen.</p>

   <p>Diese Masterarbeit wird einen tiefgreifenden Einblick in den
   Speicherverbrauch von selbst erstellten Echo-Servern bei parallelen
   Verbindungen ermöglichen und einen bedeutsamen Beitrag zur
   effizienten Entwicklung von skalierbaren Webanwendungen
   leisten.</p>
        

        

         <h4>Graphische Anwendung zum Erstellen und Bearbeiten von
         TikZ-Diagrammen</h4>
         <p> Das Textsatzsystems Tex wurde von dem Turing Award Winner
          Donald E. Knuth von 1977 bis 1986 entwickelt. In den 1980er
          hat der Turing Award Winner Leslie Lamport darauf aufbauend
          die Entwicklung von LaTeX begonnen. Primär wurde LaTeX mit
          dem Ziel entwickelt um wissenschaftliche Arbeiten,
          technische Reports und Sachbücher zu Verfassen. Ähnlich zu
          HTML lässt sich mit LaTeX die Strukturen des zu erstellenden
          Dokuments beschreiben.  Inzwischen gibt es unzählige
          Schriftsätze für LaTeX mit denen sich unter anderem 
          <a href="https://ctan.org/pkg/beamer"  target="_blank"
             rel="noopener noreferrer"> Foliensätze</a>,
             <a href="https://ctan.org/pkg/uml" target="_blank" rel="noopener noreferrer"> UML-Diagramme</a>,
            <a href="https://ctan.org/pkg/musictex" target="_blank" rel="noopener noreferrer">  Notentexte (Partituren)</a>
         oder <a href="https://ctan.org/pkg/pgf">Vektorgrafiken </a> aufschreiben lassen.
         </p>
         <p>
           Im Rahmen dieser Abschlussarbeit soll ein Programm
           implementiert werden mit dem sich einfache Blockdiagramme,
           welche die Funktionsweise von Funktionen oder Algorithmen
           beschreiben, erstellen lassen. Die Vektorgraphiken sollen
           als PGF/Tikz-Graphik gespeichert oder exportiert werden
           können.
           
           Bei <a href="https://de.wikipedia.org/wiki/PGF/TikZ"
           target="_blank" rel="noopener noreferrer"> PGF/TikZ </a>
           handelt es sich um eine Sprache zum Erstellen von
           Vektorgraphiken welche dann einfach in ein LaTeX Dokumente
           eingefügt werden können. Schauen Sie sich die
           Beispielgallerie unter
           <a href="https://texample.net/tikz/examples/"
              target="_blank" rel="noopener noreferrer">
             https://texample.net/tikz/examples/ </a> an. Dadurch
             erhalten Sie einen Eindruck welche Vielzahl an
             unterschiedlichen PGF/TikZ-Graphiken sich mit Hilfe von
             LaTeX Quellcode erstellen lassen.
         </p>
          <p>
            Der Fokus dieser Arbeit soll auf dem Softwaredesign und die
            einfacher Erweiterbarkeit liegen und noch auf dem Umfang
            der Funktionalität. Die Anwendung soll es ermöglichen
            Rechtecke und Kreise zu malen und diese mit gerichteten
            oder ungerichteten Linien zu Verbinden. Weiterhin soll eine
            Beschriftung der einzelnen Objekte möglich sein.
         </p>
          


        
          <!-- <h4>Mods für devilutionX</h4> -->
          <!-- <p> -->
          <!-- Bei devilutionX handelt es sich um eine multiplatform -->
          <!-- OpenSource Implementation von Diablo, einem ActionRPG von -->
          <!-- Blizard Entertainment aus dem Jahre 1996. Das Projekt ist in -->
          <!-- C/C++ geschrieben und unterstützt alle gängigen modernen -->
          <!-- Betriebssysteme wie Windows 10, MacOs X, Linux oder BSD. -->

          <!-- Für weiter Informationen können Sie sich die Projektseite -->
          <!-- auf Github <a target="_blank" rel="noopener noreferrer" -->
          <!-- href="https://github.com/diasurgical/devilutionX"> hier</a> -->
          <!-- ansehen. -->
          <!-- </p> -->
          <!-- <p> -->
          <!--   Im Rahmen dieser Masterarbeit soll ein Mod für dieses -->
          <!--   Spiel programmiert werden. ES folgend zwei Ideen für -->
          <!--   Sinnvolle Mods. -->
          <!-- </p> -->
          <!-- <h5>Stash</h5> -->
          <!-- <p> -->
          <!--   Dieser Mod soll es ermöglichen Gegenstände zwischen -->
          <!--   verschiedene Held*Innen auszutauschen. Dieser Mod soll als -->
          <!--   Truhe (Stash) realsiert werden. -->
          <!-- </p> -->
          <!-- <h5>Enchantment </h5> -->
          <!-- <p> -->
          <!-- Es soll möglich, das einer der Dorfbewohner (Deckard, Cain -->
          <!-- oder Adria) reguläre Gegenstände -->
          <!-- verzaubern bzw. entzaubern kann.  -->
          <!-- </p> -->
          
        
        <h4>Transparente Verschlüsselung von Ordnern </h4>
        <p>
          Bei dieser Abschlussarbeit soll unter Linux eine Lösung
          entwickelt werden, bei dem Ordner für Benutzer transparent
          verschlüsselt werden. Die Ordner müssen also transparent in
          das Dateisystem integriert werden. Der technisch unbedarfte
          Nutzer sollte keinen Unterschied zwischen einem regulären
          und einem verschlüsselten Verzeichnis feststellen. Dies
          schließt eine transparente Einbindung der verschlüsselten
          Ordner in das Dateisystem mit ein.
        </p>
        <ul class="list">
          <li>
          Die Inhalte der Ordner sollen mit Hilfe eines modernen und
          robusten AE-Schemas verschlüsselt werden. Geeignete
          Kandidaten wären beispielsweise
          <a href="https://github.com/medsec/riv" target="_blank"
          rel="noopener noreferrer">RIV</a> oder
          <a href="https://github.com/medsec/poet" target="_blank" rel="noopener noreferrer">POET</a>
          </li>
        <li>
          Der geheime Schlüssel soll dabei aus dem Login-Passwort mit
          einer modernen Key-Derivation-Funktion wie
          beispielsweise <a href="https://github.com/Tarsnap/scrypt"
          target="_blank" rel="noopener noreferrer">scrypt</a>
          oder <a href="https://github.com/medsec/catena"
          target="_blank" rel="noopener noreferrer">Catena</a>
          abgeleitet werden.
        </li>
        <li>
          Es wäre wünschenswert wenn die Lösung unter GitHub
          publiziert wird. Weiterhin würde ich mich noch sehr freuen,
          falls die Lösung als deb-Paket bereitgestellt wird.
        </li>
        </ul>

        
        <h4> Implementierung eines ioctl-Daemons (ioctld)</h4>
        <p> Mit Hilfe des Systemcalls <code>ioctl()</code> lassen sich
          gerätespezifische Eingabe- und Ausgabeoperationen
          durchführen sowie andere Operationen, die nicht durch
          reguläre Systemaufrufe ausgedrückt werden können.
          Mehr Informationen zu  <code>ioctl()</code> gibt es unter
          <a href="https://de.qwe.wiki/wiki/Ioctl(2)" target="_blank"
             rel="noopener noreferrer">https://de.qwe.wiki/wiki/Ioctl(2)</a>.
        </p>
        <p>
          Im Rahmen dieser Abschlussarbeit soll ein Daemon
          <code> ioctld </code> geschrieben werden welcher ioctl-Anfragen
          von Prozessen verarbeitet. Dabei sollen die einzelnen
          Prozesse mit dem Deamon über einen
          <a href="https://de.wikipedia.org/wiki/Unix_Domain_Socket"
             target="_blank" rel="noopener noreferrer">
            Unix-Domain-Socket </a> kommunizieren.
        </p>
        <p>
          Zusätzlich soll eine Bibliothek geschrieben werden, die es
          einem Prozess einfach ermöglicht Anfragen an
          <code> ioctld </code> zu senden.

        <p>
          Schließlich soll noch ein Berechtigungskonzept implementiert
          werden, das den Zugriff auf <code> ioctld </code> regelt.
        </p>
          

        <h4>Modernes Passwort Hashing</h4>
        <p>
          Bei dieser Abschlussarbeit soll unter Linux eine modernes
          Verfahren zum Hashen von Passwörtern entwickelt werde,
          welches resistent gegen
          <a href="https://de.wikipedia.org/wiki/Grafikprozessor"
             target="_blank" rel="noopener noreferrer">GPU</a> Angriffe
          ist, die Realisierung in Hardware
          (<a href="https://de.wikipedia.org/wiki/Anwendungsspezifische_integrierte_Schaltung"
          target="_blank" rel="noopener noreferrer">ASIC</a>) teuer
          ist und sicher
          gegen <a href="https://de.wikipedia.org/wiki/Seitenkanalattacke"
          target="_blank" rel="noopener
          noreferrer">Seitenkanalangriffe</a> ist. Ein solches
          Verfahren eignet sich nicht nur für den Einsatz auf
          Notebooks, Servern und Desktops sondern auch für den Einsatz
          in der Cloud, bei der mehrere Benutzer Hardware teilen.

          Das neue Verfahren soll dabei auf den Resultaten des
          wissenschaftlichen
          Artikels <a href="https://eprint.iacr.org/2018/944"
          target="_blank" rel="noopener noreferrer"> <q>
          Data-Independent Memory Hard Functions: New Attacks and
          Stronger Constructions </q></a> von Blocki und anderen in
          das bereits existierende
          Verfahren <a href="https://eprint.iacr.org/2013/525.pdf"
          target="_blank" rel="noopener noreferrer">Catena</a> von
          Forler und anderen integrieren.
        </p>
        <p>
          Bei der Entwicklung kann dabei auf bereits existierenden
          Sourcecode zurückgegriffen werden.
        </p>
        

        
        <!-- <h4>Dynamische Deadlock Erkennung </h4> -->
        <!-- <p> -->
        <!--   Bei dieser Abschlussarbeit soll eine Lösung entwickelt -->
        <!--   werden, mit der sich zur Laufzeit Deadlocks innerhalb eines -->
        <!--   Linux-Prozesses entdecken lassen, der PThreads verwendet. -->
        <!-- </p> -->
        <!-- <p> -->
        <!--   Die Lösung soll einen Prozess zur Laufzeit beobachten und -->
        <!--   immer den aktuellen Zustand des Betriebsmittelgraphen -->
        <!--   rendern. Falls es zu einem Deadlock kommt, soll dieser -->
        <!--   visuell hervorgehoben werden. Optional soll es möglich sein, -->
        <!--   einer der beteiligten Threads zu terminieren, um den -->
        <!--   Deadlock aufzulösen. -->
        <!-- </p> -->
        <!-- <p> -->
        <!--   Ein Guter Einstiegspunkt in die Thematik ist die -->
        <!--   wissenschaftliche Veröffentlichung   -->
        <!--   <em> Deadlock detection runtime service for Embedded Linux </em> -->
        <!--   von Glatz und anderen. -->
        <!-- </p>          -->
      </div>
    </div>
  </div>
</div>
<footer class="footer legal pure-g">
    <!--<div class="l-box">-->
        <div class="pure-u-md-1-2">
            <p class="align-left">&#x24B8; 2018-2023 Berliner Hochschule für Technik</p>
        </div>
        <div class="pure-u-md-1-2">
          <p class="link-extern align-right">
            <a href="https://www.bht-berlin.de/impressum/"
               target="_blank" rel="noopener noreferrer">
              Impressum/Datenschutz </a></p>
        </div> 
    <!--</div>-->
</footer>
</body>
</html>
