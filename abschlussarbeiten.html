<!DOCTYPE html>
<html lang="de">
<head>
  <title>Prof. Dr. Christian Forler</title>
  <meta name="referrer" content="no-referrer">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="style-src 'self'">


  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/pure.css">
  <link rel="stylesheet" href="css/grids-responsive-min.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="icon" href="images/favicon_bht.ico" type="image/x-icon; charset=binary">
  
</head>
<body>
<div class="beuth-div">
  <a href="https://www.bht-berlin.de" target="_blank" rel="noopener noreferrer" >
    <img class="beuth-img" src="images/BHT_Logo_horizontal_Anthrazit_transparent.svg" alt="Logo der Berliner Hochschule für Technik">
  </a>
</div>

<nav class="pure-menu pure-menu-horizontal">
  <a href="index.html" class="pure-menu-heading pure-menu-link">Prof. Dr. Christian Forler</a>
  <ul class="pure-menu-list">
    <li class="pure-menu-item"><a href="abschlussarbeiten.html"
                                  class="pure-menu-link">Themen für Abschlussarbeiten</a></li>
    <li class="pure-menu-item"><a href="leitfaden.html"
                                  class="pure-menu-link">Leitfaden für Abschlussarbeiten</a></li>
     <li class="pure-menu-item"><a href="oral_examination.html"
                                  class="pure-menu-link">Leitfaden
         für mündliche Prüfungen</a></li>

     <li class="pure-menu-item"><a href="crashkurs.html" class="pure-menu-link">Programmieren</a></li>
  </ul>
</nav>
<div class="content">
  <div class="pure-g">
    <div class="pure-u-md-1">
      <div class="l-box">
        <h1>Themen für Abschlussarbeiten</h1>

        <!--        
                    <h2>Abschlussarbeiten des PSE-Labors</h2>
        <p>
          Als Mitglied
          des <a href="https://labor.bht-berlin.de/pse"
                 target="_blank" rel="noopener noreferrer">PSE-Labors</a>
          betreue ich auch ausgewählte Abschlussarbeiten, die dort
          ausgeschrieben sind. Eine Übersicht gibt es <a href="https://labor.bht-berlin.de/pse/acalab-aktivitaeten-und-abschlussarbeiten/" target="_blank" rel="noopener noreferrer">hier</a>.
        </p>
        
        <h2> Abschlussarbeiten in eigener Regie </h2>
        -->
        <h2>Bachelorarbeiten</h2>

        <h4>Web-Authentication basierend auf Asymmetrischer Kryptographie</h4>

        <p>Bei dieser Arbeit soll eine Webanwendung entwickelt werden, bei der
          sich der Nutzer nicht mit seinem Passwort, sondern mit digitalen
          Unterschriften authentifiziert. Der geheime Schlüssel muss hierbei im
          Webbrowser gespeichert werden. Gegebenenfalls muss hier ein Plugin
          entwickelt werden. Für eine Proof-of-Concept (PoC)-Implementierung
          kann der geheime Schlüssel auch base64-kodiert in einem Secure-Cookie
          gespeichert werden. Der dazugehörige öffentliche Schlüssel kann
          zusammen mit den restlichen Nutzerdaten in einer Datenbank gespeichert
          werden.</p>

        <p>Bei der Anmeldung soll der Client zunächst eine 128-Bit
          Zufallszahl <code>R</code> digital signieren und an den Server
          senden. Der Server verifiziert die Signatur und generiert ebenfalls
          eine 128-Bit Zufallszahl <code>S</code>, die er an den Client
          sendet. Anschließend signiert der Client die Nachricht <code>(S,
            R)</code> mit seinem geheimen Schlüssel und sendet die Signatur an den
          Server, welcher diese verifiziert. Bei erfolgreicher Verifizierung ist
          der Nutzer angemeldet.</p>

        <p>Die Implementierung kann mithilfe der kryptographischen
          Bibliothek <a href="https://nacl.cr.yp.to/" target="_blank"
                        rel="noopener noreferrer">NaCl</a> realisiert werden. Hier sind ein
          paar Implementierungen dieser Bibliothek für die
          Skript-/Programmiersprachen C, Python und Javascript:</p>

        <ul>
          <li><a href="https://www.npmjs.com/package/js-nacl" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/package/js-nacl</a></li>
          <li><a href="https://doc.libsodium.org/" target="_blank" rel="noopener noreferrer">https://doc.libsodium.org/</a></li>
          <li><a href="https://pypi.org/project/libnacl/" target="_blank" rel="noopener noreferrer">https://pypi.org/project/libnacl/</a></li>
        </ul>

        

        

        <h4>Editor für SAVE.DAT-Dateien</h4>
        <p>Bei SAVE.DAT handelt es sich um ein Dateiformat, welches
          bei den Computerspielen Fallout und Fallout 2 zur Anwendung
          kommt, um Spielstände zu sichern. Im Rahmen der
          Abschlussarbeit soll eine C/C++- oder Rust-Anwendung für
          Linux geschrieben werden, bei der alle relevanten
          Informationen einer SAVE.DAT-Datei menschenlesbar ausgegeben
          und editiert werden können. Die Anwendung soll dabei nur
          Bibliotheken verwenden, die auch Teil der Debian GNU/Linux
          Distribution sind. Bei dieser Arbeit bietet sich ein CLI-,
          GUI- oder ncurses-basiertes Nutzerinterface an. Mehr zu dem
          SAVE.DAT-Dateiformat finden
          Sie <a href="https://fallout.wiki/wiki/SAVE.DAT_File_Format"
                 target="_blank" rel="noopener noreferrer">hier</a>
          und <a href="https://falloutmods.fandom.com/wiki/SAVE.DAT_File_Format"
                 target="_blank" rel="noopener noreferrer">hier</a>.
        </p>

        
        <h4> Filmbewertungs-Aggregator</h4>
        <p>Die Abschlussarbeit beschäftigt sich mit der Entwicklung
          einer anwendungsübergreifenden Lösung zur Aggregation und
          Anzeige von Filmbewertungen von "Rotten Tomatoes" und
          "Metacritic". </p>
        
        <p>Die entwickelte Anwendung wird lokal auf einem
          Linux-Rechner laufen und die APIs von "Rotten Tomatoes" und
          "Metacritic" integrieren, um aktuelle Bewertungen für eine
          definierte Filmauswahl abzurufen. Die aggregierten
          Bewertungen werden dann über eine gut strukturierte UI zur
          Verfügung gestellt.</p>

        <p>Zusätzlich zur Bewertungsabfrage SOLL auch einen
          effizienten Caching-Mechanismus implementieren.
        </p>
        
        <p> Das Ziel ist es, eine benutzerfreundliche Anwendung zu
          entwickeln, die es ermöglicht, nahtlos auf
          Filmbewertungsdaten zuzugreifen und diese gut strukturiert
          darzustellen.</p>

        <h4>Visualisierung von Operationen auf einem  AVL-Baum</h4>
        <p>
          Im Rahmen dieser Abschlussarbeit soll eine Anwendung erstellt
          werden, welche die Einfüge- und Löschoperation bei einem 
          <a href="https://de.wikipedia.org/wiki/AVL-Baum" target="_blank"
             rel="noopener noreferrer"> AVL-Baum</a>
          visualisiert. Im Fokus stehen hier die Einfach- und
          Doppelrotationen. Die Anwendung soll noch die weiteren Anforderungen erfüllen
          <ul class="list">
            <li> Exportieren eines AVL-Baums in einen menschenlesbare Form.</li>
            <li> Importieren eines AVL-Baums aus einer Datei. </li>
            <li> Anzeige der einzelnen AVL-Werte. </li>
            <li> Konvertierung eines beliebigen binären Suchbaum in einen AVL-Baum.</li>
            <li> Animierte Einfach- und Doppelrotationen. </li>
            <li> Unterstützung von Bäumen mit bis zu 63 Knoten. </li>
            <li> (OPTIONAL) Gamification Aspekte. </li>
          </ul>
          
          
          <h4> Design Entwicklung einer interaktiven Anwendung zur
            Visualisierung von Betriebsmodi in der Kryptographie.</h4>
          
        <p>In dieser Bachelorarbeit wird eine interaktive Anwendung
          entwickelt, die es Studierenden ermöglicht, die Betriebsmodi
          ECB (Electronic Codebook), CBC (Cipher Block Chaining) und
          Counter-Mode in der Kryptographie zu verstehen und zu
          visualisieren. Die Anwendung dient als lehrreiches Tool, um
          das grundlegende Konzept der verschiedenen Betriebsmodi zu
          erklären.</p >
        
        <p>Die entwickelte Anwendung bietet eine benutzerfreundliche
          Oberfläche, auf der die Studierenden die Funktionsweise der
          Betriebsmodi nachvollziehen können. Es sollen visuell die
          Verarbeitung der einzelnen Klartext- bzw. Chiffretextblöcke
          veranschaulicht werden.</p>

        <p>Ein wichtiges Feature der Anwendung ist die Möglichkeit,
          für kleine vorgegebene (2-6 Bit) Blockchiffren, entweder
          Klartexte manuell zu verschlüsseln oder Chiffretexte wieder
          manuell zu entschlüsseln. Dadurch können die Studierenden
          aktiv anhand praktischer Beispiele die Verwendung der
          verschiedenen Betriebsmodi erleben und ihr Verständnis
          vertiefen.</p>
        

        <h4>Visualisierung der Tiefensuche</h4>
        <p>
          Im Rahmen dieser Abschlussarbeit soll eine Anwendung
          erstellt werden, welche die
          <a href="https://de.wikipedia.org/wiki/Tiefensuche"
             target="_blank" rel="noopener noreferrer">
            Tiefensuche</a> visualisiert. Und zwar soll mittels der
          Tiefensuche ein Ausgang aus einem Labyrinth gefunden
          werden. Folgende Features sollen implementiert werden:
        </p>
        <ul class="list">
          <li>
            Editierend von Labyrinthen
          </li>
          <li>
            Speichern und Laden von Labyrinthen.
          </li>
          <li>
            Der Startpunkt und das Ziel/Ausgang soll frei wählbar sein.
          </li>
          <li>
            GNU/Linux Unterstützung.
          </li>
        </ul>
        
        
        <h4>Anwendung zur Veranschaulichung von Sortierverfahren</h4>
        <p>
          Im Rahmen dieser Abschlussarbeit soll ein Anwendung für
          die Lehre implementiert werden. Ziel der Anwendung ist es zum
          einen den NutzerInnen Sortierverfahren verständlich zu
          erläutern und zum anderen durch Test herausfinden, ob diese
          auch verstanden wurden. Insgesamt soll die Anwendung die
          folgenden fünf Sortierverfahren abdecken.
        </p>
        <ol>
          <li> BubbleSort    </li>
          <li> InsertionSort </li>
          <li> MergeSort     </li>
          <li> HeapSort      </li>
        </ol>
        <p>
          Die einzelnen Implementierungen sollen dabei den Definitionen
          aus meinen Lehrmaterialien zu dem Modul <q> Algorithmen und
            Datenstrukturen </q> entsprechen. Daher sind sie
          eigenständig zu implementieren.

          
          Die Anwendung kann beispielsweise über einen Erklär- und
          einen Testmodus verfügen. Bei dem Erklärmodus können die
          Sortierverfahren durch Animationen (spielerisch)
          näher gebracht werden.
          
          In dem Testmodus sollen unsortiertes Array mithilfe eines
          angegeben Sortierverfahrens sortiert werden. Dabei soll die
          NutzerInnen natürlich Feedback bekommen, ob Sie alles richtig
          gemacht haben und falls nicht soll veranschaulicht werden, wo
          es hakte.
        </p>

        <p>
          Ein wichtiger Aspekt dieser Arbeit ist selbstverständlich
          die Usability der Anwendung. Gerne kann auch die Motivation
          zur Nutzung der Anwendung mithilfe von Gamification Aspekten
          optimiert werden.

          Ich kann mir gut vorstellen, diese Anwendung in eine Art
          Spiel zu verpacken. Ein Beispiel für ein Spiel durch das
          die NutzerInnen Assembler lernen
          ist <a href="https://en.wikipedia.org/wiki/Human_Resource_Machine"
                 target="_blank" rel="noopener noreferrer"> Human Resource
            Machine </a>. Wie Sie sehen ist bei dieser Arbeit der
          Kreativität keine Grenzen gesetzt.
        </p>
        

        <h4>Generierung von UML-Diagrammen</h4>
        <p>
          Im Rahmen dieser Abschlussarbeit soll eine Bibliothek
          erstellt werden die aus C++ oder Java-Klassen
          einliest und daraus ein UML-Klassendiagramm erstellt.
        </p>
        <p>
          Aufgabe ist es also das parsen von Quelldateien und die
          Generierung von Vektorgraphiken welche sich möglichst
          einfach in ein LaTeX Dokument, wie beispielsweise eine
          Abschlussarbeit, integrieren lassen sollen. Es ist wäre
          wünschenswert, falls die LaTeX-Ausgabe kompatibel zu zu dem
          CTAN-Paket <a href="https://ctan.org/pkg/uml"
                        target="_blank" rel="noopener noreferrer"> UML </a> ist.
        </p>
        
        <h4>Privilege Separation Bibliothek</h4>
        <p>
          In dieser Arbeit soll eine Bibliothek für Linux programmiert
          werden, mit der sich
          <a href="https://en.wikipedia.org/wiki/Privilege_separation" target="_blank" rel="noopener noreferrer">Privilege separation</a> realisieren lässt. Hierbei handelt es sich um ein Prinzip, bei dem ein Programm nur mit den Privilegien arbeitet, welche für die Erledigung der Aufgabe nötig sind.
        </p>
        <p>
          Die Bibliothek soll möglichst einfach das folgende Verhalten
          unterstützen: Ein Programm wird zunächst mit Root-Rechten
          gestartet und erstellt zwei Pipes, um eine bidirektionale
          Kommunikation mit seinem Kindprozess zu ermöglichen, welcher im
          Anschluss generiert wird. Die <i>Privilegien</i> des Kindprozesses
          werden mit der <i>Systemcall-Sandbox</i>
          <a href="https://code.google.com/archive/p/seccompsandbox/wikis/overview.wiki" target="_blank" rel="noopener noreferrer">seccomp</a> eingeschränkt. Der Elternprozess gibt seine Root-Rechte ab und läuft dann als unprivilegierter Prozess weiter. Privilegierte Operationen werden vom Elternprozess an das Kind delegiert.
        </p>
        p>

        
        <h4>Dateiverschlüsselung für Cloudstorage</h4>
        <p>
          In dieser Abschlussarbeit soll unter Linux eine Lösung
          entwickelt werden, um Dateien sicher in einem oder über
          mehrere Cloudspeicher hinweg zu speichern. Dazu sollen die
          Dateien verschlüsselt werden. Der Chiffretext soll dabei in
          4-KiB große Blöcke zerlegt werden. Der Dateiname soll den
          Hashwert des Inhalts darstellen.
        </p>
        <p>
          Informationen darüber, welche Blöcke zu welcher Datei
          gehören, können beispielsweise in einer Datenbank
          gespeichert werden. Diese Datenbank kann zusätzliche
          Metadaten wie Dateinamen und Zugriffsrechte enthalten. Es
          soll die Möglichkeit geben, anzugeben, in welchem Ordner die
          Chiffretextblöcke gespeichert werden. Wenn mehrere Ordner
          angegeben werden, sollen die Chiffretextblöcke zufällig auf
          diese Ordner verteilt werden.
        </p><p> Diese Vorgehensweise ermöglicht es, Dateien über
          mehrere Cloudspeicherlösungen – die als Ordner im
          Dateisystem eingebunden sind – zu verteilen. Der Schlüssel
          soll mit einem Passwort gesichert werden, das beispielsweise
          via XOR mit einem Passworthash kombiniert werden kann.
        </p>
        <ul class="list">
          <li>
            Die Dateien sollen mithilfe eines modernen und robusten AE-Schemas
            (Authenticated Encryption) verschlüsselt werden. Geeignete
            Kandidaten wären beispielsweise
            <a href="https://github.com/medsec/riv" target="_blank"
               rel="noopener noreferrer">RIV</a> oder
            <a href="https://github.com/medsec/poet" target="_blank"
               rel="noopener noreferrer">POET</a>.
          </li>
          <li>
            Der geheime Schlüssel soll aus dem Login-Passwort mithilfe einer
            modernen Key-Derivation-Funktion (KDF) abgeleitet werden, wie
            beispielsweise
            <a href="https://github.com/Tarsnap/scrypt" target="_blank"
               rel="noopener noreferrer">scrypt</a> oder
            <a href="https://github.com/medsec/catena" target="_blank" rel="noopener noreferrer">Catena</a>.
          </li>
        </ul>

        
        
        <h2>Masterarbeiten</h2>

        

        <h4>Vergleich des Speicherverbrauchs eigener Implementierungen von Echo-Servern bei parallelen Verbindungen</h4>
        <p>Die Masterarbeit widmet sich einem detaillierten Vergleich des
          Speicherverbrauchs von selbst erstellten Echo-Servern, die in
          verschiedenen Programmiersprachen und Frameworks implementiert sind,
          bei unterschiedlichen parallelen Verbindungen. Ein Echo-Server ist
          ein einfacher Server, der die empfangenen Daten zurücksendet, ohne
          diese zu verarbeiten. In dieser Arbeit werden eigene
          Implementierungen der Echo-Server in den folgenden
          Programmiersprachen und Frameworks erstellt und verglichen:</p>
        <ul>
          <li>C (epoll oder select)</li>
          <li>Spring Framework</li>
          <li>Express Framework</li>
          <li>Django Framework</li>
          <li>Rails Framework</li>
          <li>Laravel Framework</li>
        </ul>
        <p>Das Hauptziel der Arbeit ist es, den Speicherverbrauch jeder
          eigenen Implementierung bei 10, 100, 1.000 und 10.000 parallelen
          Verbindungen zu analysieren und zu vergleichen. Diese
          unterschiedlichen Lastszenarien ermöglichen es, die Skalierbarkeit
          und Effizienz der eigenen Echo-Server unter verschiedenen
          Belastungen zu bewerten.</p>
        
        <p>Die Masterarbeit wird eine umfangreiche Umsetzung der eigenen
          Echo-Server-Implementierungen beinhalten. Dabei werden spezifische
          Testumgebungen geschaffen, um die parallelen Verbindungen zu
          simulieren und den Speicherverbrauch präzise zu messen.</p>

        <p>Die erzielten Ergebnisse werden sorgfältig dokumentiert und in
          einer übersichtlichen Form präsentiert. Die gewonnenen Erkenntnisse
          werden wertvolle Informationen für die Entwicklergemeinschaft
          liefern, um die optimale Implementierung für
          Echo-Server-Anwendungen zu wählen. Die Arbeit wird zudem als
          wertvolle Grundlage dienen, um die Leistung und Skalierbarkeit von
          Webanwendungen zu verbessern und fundierte Entscheidungen
          hinsichtlich der Auswahl des geeigneten Frameworks zu treffen.</p>

        <p>Diese Masterarbeit wird einen tiefgreifenden Einblick in den
          Speicherverbrauch von selbst erstellten Echo-Servern bei parallelen
          Verbindungen ermöglichen und einen bedeutsamen Beitrag zur
          effizienten Entwicklung von skalierbaren Webanwendungen
          leisten.</p>
        

        

        <h4>Graphische Anwendung zum Erstellen und Bearbeiten von
          TikZ-Diagrammen</h4>
        <p> Das Textsatzsystems Tex wurde von dem Turing Award Winner
          Donald E. Knuth von 1977 bis 1986 entwickelt. In den 1980er
          hat der Turing Award Winner Leslie Lamport darauf aufbauend
          die Entwicklung von LaTeX begonnen. Primär wurde LaTeX mit
          dem Ziel entwickelt um wissenschaftliche Arbeiten,
          technische Reports und Sachbücher zu Verfassen. Ähnlich zu
          HTML lässt sich mit LaTeX die Strukturen des zu erstellenden
          Dokuments beschreiben.  Inzwischen gibt es unzählige
          Schriftsätze für LaTeX mit denen sich unter anderem 
          <a href="https://ctan.org/pkg/beamer"  target="_blank"
             rel="noopener noreferrer"> Foliensätze</a>,
          <a href="https://ctan.org/pkg/uml" target="_blank" rel="noopener noreferrer"> UML-Diagramme</a>,
          <a href="https://ctan.org/pkg/musictex" target="_blank" rel="noopener noreferrer">  Notentexte (Partituren)</a>
          oder <a href="https://ctan.org/pkg/pgf">Vektorgrafiken </a> aufschreiben lassen.
        </p>
        <p>
          Im Rahmen dieser Abschlussarbeit soll ein Programm
          implementiert werden mit dem sich einfache Blockdiagramme,
          welche die Funktionsweise von Funktionen oder Algorithmen
          beschreiben, erstellen lassen. Die Vektorgraphiken sollen
          als PGF/Tikz-Graphik gespeichert oder exportiert werden
          können.
          
          Bei <a href="https://de.wikipedia.org/wiki/PGF/TikZ"
                 target="_blank" rel="noopener noreferrer"> PGF/TikZ </a>
          handelt es sich um eine Sprache zum Erstellen von
          Vektorgraphiken welche dann einfach in ein LaTeX Dokumente
          eingefügt werden können. Schauen Sie sich die
          Beispielgallerie unter
          <a href="https://texample.net/tikz/examples/"
             target="_blank" rel="noopener noreferrer">
            https://texample.net/tikz/examples/ </a> an. Dadurch
          erhalten Sie einen Eindruck welche Vielzahl an
          unterschiedlichen PGF/TikZ-Graphiken sich mit Hilfe von
          LaTeX Quellcode erstellen lassen.
        </p>
        <p>
          Der Fokus dieser Arbeit soll auf dem Softwaredesign und die
          einfacher Erweiterbarkeit liegen und noch auf dem Umfang
          der Funktionalität. Die Anwendung soll es ermöglichen
          Rechtecke und Kreise zu malen und diese mit gerichteten
          oder ungerichteten Linien zu Verbinden. Weiterhin soll eine
          Beschriftung der einzelnen Objekte möglich sein.
        </p>
        


        
        <!-- <h4>Mods für devilutionX</h4> -->
        <!-- <p> -->
          <!-- Bei devilutionX handelt es sich um eine multiplatform -->
          <!-- OpenSource Implementation von Diablo, einem ActionRPG von -->
          <!-- Blizard Entertainment aus dem Jahre 1996. Das Projekt ist in -->
          <!-- C/C++ geschrieben und unterstützt alle gängigen modernen -->
          <!-- Betriebssysteme wie Windows 10, MacOs X, Linux oder BSD. -->

          <!-- Für weiter Informationen können Sie sich die Projektseite -->
          <!-- auf Github <a target="_blank" rel="noopener noreferrer" -->
          <!-- href="https://github.com/diasurgical/devilutionX"> hier</a> -->
          <!-- ansehen. -->
          <!-- </p> -->
        <!-- <p> -->
          <!--   Im Rahmen dieser Masterarbeit soll ein Mod für dieses -->
          <!--   Spiel programmiert werden. ES folgend zwei Ideen für -->
          <!--   Sinnvolle Mods. -->
          <!-- </p> -->
        <!-- <h5>Stash</h5> -->
        <!-- <p> -->
          <!--   Dieser Mod soll es ermöglichen Gegenstände zwischen -->
          <!--   verschiedene Held*Innen auszutauschen. Dieser Mod soll als -->
          <!--   Truhe (Stash) realsiert werden. -->
          <!-- </p> -->
        <!-- <h5>Enchantment </h5> -->
        <!-- <p> -->
          <!-- Es soll möglich, das einer der Dorfbewohner (Deckard, Cain -->
          <!-- oder Adria) reguläre Gegenstände -->
          <!-- verzaubern bzw. entzaubern kann.  -->
          <!-- </p> -->
        
        
        <h4>Transparente Verschlüsselung von Ordnern </h4>
        <p>
          Bei dieser Abschlussarbeit soll unter Linux eine Lösung
          entwickelt werden, bei dem Ordner für Benutzer transparent
          verschlüsselt werden. Die Ordner müssen also transparent in
          das Dateisystem integriert werden. Der technisch unbedarfte
          Nutzer sollte keinen Unterschied zwischen einem regulären
          und einem verschlüsselten Verzeichnis feststellen. Dies
          schließt eine transparente Einbindung der verschlüsselten
          Ordner in das Dateisystem mit ein.
        </p>
        <ul class="list">
          <li>
            Die Inhalte der Ordner sollen mit Hilfe eines modernen und
            robusten AE-Schemas verschlüsselt werden. Geeignete
            Kandidaten wären beispielsweise
            <a href="https://github.com/medsec/riv" target="_blank"
               rel="noopener noreferrer">RIV</a> oder
            <a href="https://github.com/medsec/poet" target="_blank" rel="noopener noreferrer">POET</a>
          </li>
          <li>
            Der geheime Schlüssel soll dabei aus dem Login-Passwort mit
            einer modernen Key-Derivation-Funktion wie
            beispielsweise <a href="https://github.com/Tarsnap/scrypt"
                              target="_blank" rel="noopener noreferrer">scrypt</a>
            oder <a href="https://github.com/medsec/catena"
                    target="_blank" rel="noopener noreferrer">Catena</a>
            abgeleitet werden.
          </li>
          <li>
            Es wäre wünschenswert wenn die Lösung unter GitHub
            publiziert wird. Weiterhin würde ich mich noch sehr freuen,
            falls die Lösung als deb-Paket bereitgestellt wird.
          </li>
        </ul>

        
        <h4> Implementierung eines ioctl-Daemons (ioctld)</h4>
        <p> Mit Hilfe des Systemcalls <code>ioctl()</code> lassen sich
          gerätespezifische Eingabe- und Ausgabeoperationen
          durchführen sowie andere Operationen, die nicht durch
          reguläre Systemaufrufe ausgedrückt werden können.
          Mehr Informationen zu  <code>ioctl()</code> gibt es unter
          <a href="https://de.qwe.wiki/wiki/Ioctl(2)" target="_blank"
             rel="noopener noreferrer">https://de.qwe.wiki/wiki/Ioctl(2)</a>.
        </p>
        <p>
          Im Rahmen dieser Abschlussarbeit soll ein Daemon
          <code> ioctld </code> geschrieben werden welcher ioctl-Anfragen
          von Prozessen verarbeitet. Dabei sollen die einzelnen
          Prozesse mit dem Deamon über einen
          <a href="https://de.wikipedia.org/wiki/Unix_Domain_Socket"
             target="_blank" rel="noopener noreferrer">
            Unix-Domain-Socket </a> kommunizieren.
        </p>
        <p>
          Zusätzlich soll eine Bibliothek geschrieben werden, die es
          einem Prozess einfach ermöglicht Anfragen an
          <code> ioctld </code> zu senden.

        <p>
          Schließlich soll noch ein Berechtigungskonzept implementiert
          werden, das den Zugriff auf <code> ioctld </code> regelt.
        </p>
        

        <h4>Modernes Passwort Hashing</h4>
        <p>
          Bei dieser Abschlussarbeit soll unter Linux eine modernes
          Verfahren zum Hashen von Passwörtern entwickelt werde,
          welches resistent gegen
          <a href="https://de.wikipedia.org/wiki/Grafikprozessor"
             target="_blank" rel="noopener noreferrer">GPU</a> Angriffe
          ist, die Realisierung in Hardware
          (<a href="https://de.wikipedia.org/wiki/Anwendungsspezifische_integrierte_Schaltung"
              target="_blank" rel="noopener noreferrer">ASIC</a>) teuer
          ist und sicher
          gegen <a href="https://de.wikipedia.org/wiki/Seitenkanalattacke"
                   target="_blank" rel="noopener
                                        noreferrer">Seitenkanalangriffe</a> ist. Ein solches
          Verfahren eignet sich nicht nur für den Einsatz auf
          Notebooks, Servern und Desktops sondern auch für den Einsatz
          in der Cloud, bei der mehrere Benutzer Hardware teilen.

          Das neue Verfahren soll dabei auf den Resultaten des
          wissenschaftlichen
          Artikels <a href="https://eprint.iacr.org/2018/944"
                      target="_blank" rel="noopener noreferrer"> <q>
              Data-Independent Memory Hard Functions: New Attacks and
              Stronger Constructions </q></a> von Blocki und anderen in
          das bereits existierende
          Verfahren <a href="https://eprint.iacr.org/2013/525.pdf"
                       target="_blank" rel="noopener noreferrer">Catena</a> von
          Forler und anderen integrieren.
        </p>
        <p>
          Bei der Entwicklung kann dabei auf bereits existierenden
          Sourcecode zurückgegriffen werden.
        </p>
        

        
        <!-- <h4>Dynamische Deadlock Erkennung </h4> -->
        <!-- <p> -->
          <!--   Bei dieser Abschlussarbeit soll eine Lösung entwickelt -->
          <!--   werden, mit der sich zur Laufzeit Deadlocks innerhalb eines -->
          <!--   Linux-Prozesses entdecken lassen, der PThreads verwendet. -->
          <!-- </p> -->
        <!-- <p> -->
          <!--   Die Lösung soll einen Prozess zur Laufzeit beobachten und -->
          <!--   immer den aktuellen Zustand des Betriebsmittelgraphen -->
          <!--   rendern. Falls es zu einem Deadlock kommt, soll dieser -->
          <!--   visuell hervorgehoben werden. Optional soll es möglich sein, -->
          <!--   einer der beteiligten Threads zu terminieren, um den -->
          <!--   Deadlock aufzulösen. -->
          <!-- </p> -->
        <!-- <p> -->
          <!--   Ein Guter Einstiegspunkt in die Thematik ist die -->
          <!--   wissenschaftliche Veröffentlichung   -->
          <!--   <em> Deadlock detection runtime service for Embedded Linux </em> -->
          <!--   von Glatz und anderen. -->
          <!-- </p>          -->
      </div>
    </div>
  </div>
</div>
<footer class="footer legal pure-g">
    <!--<div class="l-box">-->
        <div class="pure-u-md-1-2">
            <p class="align-left">&#x24B8; 2018-2023 Berliner Hochschule für Technik</p>
        </div>
        <div class="pure-u-md-1-2">
          <p class="link-extern align-right">
            <a href="https://www.bht-berlin.de/impressum/"
               target="_blank" rel="noopener noreferrer">
              Impressum/Datenschutz </a></p>
        </div> 
    <!--</div>-->
</footer>
</body>
</html>
