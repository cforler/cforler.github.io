<!DOCTYPE html>
<html lang="de">
<head>
  <title>Prof. Dr. Christian Forler</title>
  <meta name="referrer" content="no-referrer">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="style-src 'self'">


  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/pure.css">
  <link rel="stylesheet" href="css/grids-responsive-min.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="icon" href="images/favicon_bht.ico" type="image/x-icon; charset=binary">
  
</head>
<body>
<div class="beuth-div">
  <a href="https://www.bht-berlin.de" target="_blank" rel="noopener noreferrer" >
    <img class="beuth-img" src="images/BHT_Logo_horizontal_Anthrazit_transparent.svg" alt="Logo der Berliner Hochschule für Technik">
  </a>
</div>

<nav class="pure-menu pure-menu-horizontal">
  <a href="index.html" class="pure-menu-heading pure-menu-link">Prof. Dr. Christian Forler</a>
  <ul class="pure-menu-list">
    <li class="pure-menu-item"><a href="abschlussarbeiten.html"
                                  class="pure-menu-link">Themen für Abschlussarbeiten</a></li>
    <li class="pure-menu-item"><a href="leitfaden.html"
                                  class="pure-menu-link">Leitfaden für Abschlussarbeiten</a></li>
     <li class="pure-menu-item"><a href="oral_examination.html"
                                  class="pure-menu-link">Leitfaden
         für mündliche Prüfungen</a></li>

     <li class="pure-menu-item"><a href="crashkurs.html" class="pure-menu-link">Programmieren</a></li>
  </ul>
</nav>
<div class="content">
  <div class="pure-g">
    <div class="pure-u-md-1">
      <div class="l-box">
        <h1>Themen für Abschlussarbeiten</h1>

        <h4>Entwicklung einer Spiele-Engine für Puzzle-Videospiel
          mit visuellem Programmieransatz
        </h4>
        <p>      
          Im Rahmen dieser Bachelorarbeit soll eine einfache
          Spiele-Engine für Puzzle-Videospiel mit visuellem
          Programmieransatz wie
          <a href="https://en.wikipedia.org/wiki/Human_Resource_Machine"
             target="_blank">Human Resource Machine</a> entwickelt
          werden. Ziel ist es, eine lauffähige Demo-Anwendung mit einem
          Demo-Level zu erstellen, die unter Linux betrieben werden
          kann. Die Engine soll grundlegende Mechanismen zur
          Darstellung, Steuerung und Auswertung von spielbasierten
          Programmieraufgaben bereitstellen.
        </p>
        
        <h4>Anwendung zur Veranschaulichung von Scheduling-Verfahren</h4>
        <p>
          In dieser Bachelorarbeit wird eine visuelle und interaktive
          Anwendung entwickelt, die es Studierenden ermöglicht, die
          folgenden präemptiven Scheduling-Strategien besser zu
          verstehen:
        </p>
        <ul class="list">
          <li>Last Come First Served</li>
          <li>Round Robin</li>
          <li>Strict Priority Scheduling</li>
          <li>Multilevel-Feedback Scheduling</li>
        </ul>
        <p>
          Die Anwendung dient als didaktisches Tool, um die grundlegenden Konzepte der verschiedenen 
          Scheduling-Strategien anschaulich zu erklären.
        </p>

        
        <h4>Visualisierung der Tiefensuche</h4>
        <p>
          Im Rahmen dieser Abschlussarbeit soll eine Anwendung
          erstellt werden, welche die
          <a href="https://de.wikipedia.org/wiki/Tiefensuche"
             target="_blank" rel="noopener noreferrer">
            Tiefensuche</a> visualisiert. Und zwar soll mittels der
          Tiefensuche ein Ausgang aus einem Labyrinth gefunden
          werden. Folgende Features sollen implementiert werden:
        </p>
        <ul class="list">
          <li>
            Editierend von Labyrinthen
          </li>
          <li>
            Speichern und Laden von Labyrinthen.
          </li>
          <li>
            Der Startpunkt und das Ziel/Ausgang soll frei wählbar sein.
          </li>
          <li>
            GNU/Linux Unterstützung.
          </li>
        </ul>
        
        <h4>Konzeption und Umsetzung von Gameplay-Erweiterungen für devilutionX</h4>
        <p>
          Bei <em>devilutionX</em> handelt es sich um eine
          plattformübergreifende Open-Source-Implementierung
          von <em>Diablo</em>, einem Action-RPG von Blizzard Entertainment aus
          dem Jahr 1996.  Das Projekt ist in C/C++ geschrieben und unterstützt
          alle gängigen modernen Betriebssysteme wie Windows 10, macOS, Linux
          oder BSD.
        </p>
        <p>
          Weitere Informationen finden Sie auf der 
          <a target="_blank" rel="noopener noreferrer" href="https://github.com/diasurgical/devilutionX">Projektseite auf GitHub</a>.
        </p>
        <p>
          Im Rahmen dieser Masterarbeit soll ein Mod für dieses Spiel entwickelt werden. 
          Nachfolgend werden zwei Ideen für sinnvolle Erweiterungen vorgestellt.
        </p>

        <h5>Stash</h5>
        <p>
          Dieser Mod soll es ermöglichen, Gegenstände zwischen verschiedenen
          Heldinnen und Helden auszutauschen.
        </p>

        <h5>Enchantment</h5>
        <p>
          Es soll möglich sein, dass einer der Dorfbewohner (Deckard Cain oder
          Adria) reguläre Gegenstände ver- bzw. entzaubern kann.
        </p>

        

        
        <h4>Web-Authentication basierend auf Asymmetrischer Kryptographie</h4>

        <p>Bei dieser Arbeit soll eine Webanwendung entwickelt werden, bei der
          sich der Nutzer nicht mit seinem Passwort, sondern mit digitalen
          Unterschriften authentifiziert. Der geheime Schlüssel muss hierbei im
          Webbrowser gespeichert werden. Gegebenenfalls muss hier ein Plugin
          entwickelt werden. Für eine Proof-of-Concept (PoC)-Implementierung
          kann der geheime Schlüssel auch base64-kodiert in einem Secure-Cookie
          gespeichert werden. Der dazugehörige öffentliche Schlüssel kann
          zusammen mit den restlichen Nutzerdaten in einer Datenbank gespeichert
          werden.</p>

        <p>Bei der Anmeldung soll der Client zunächst eine 128-Bit
          Zufallszahl <code>R</code> digital signieren und an den Server
          senden. Der Server verifiziert die Signatur und generiert ebenfalls
          eine 128-Bit Zufallszahl <code>S</code>, die er an den Client
          sendet. Anschließend signiert der Client die Nachricht <code>(S,
            R)</code> mit seinem geheimen Schlüssel und sendet die Signatur an den
          Server, welcher diese verifiziert. Bei erfolgreicher Verifizierung ist
          der Nutzer angemeldet.</p>

        <p>Die Implementierung kann mithilfe der kryptographischen
          Bibliothek <a href="https://nacl.cr.yp.to/" target="_blank"
                        rel="noopener noreferrer">NaCl</a> realisiert werden. Hier sind ein
          paar Implementierungen dieser Bibliothek für die
          Skript-/Programmiersprachen C, Python und Javascript:</p>

        <ul>
          <li><a href="https://www.npmjs.com/package/js-nacl" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/package/js-nacl</a></li>
          <li><a href="https://doc.libsodium.org/" target="_blank" rel="noopener noreferrer">https://doc.libsodium.org/</a></li>
          <li><a href="https://pypi.org/project/libnacl/" target="_blank" rel="noopener noreferrer">https://pypi.org/project/libnacl/</a></li>
        </ul>

        <h4>Aktualisierung und Erweiterung des Moodle-Plugins "All or Nothing Question Type"</h4>
        <p> Im Rahmen dieser Abschlussarbeit wird das
          Moodle-Plugin <strong>"All or Nothing Question Type"</strong>
          (siehe <a href="https://github.com/ecampbell/moodle-qtype_multichoiceset"
                    target="_blank">GitHub-Repository</a>) weiterentwickelt und
          optimiert. Das Plugin, das bereits eine wertvolle Funktion in
          Moodle-basierten Lernmanagementsystemen bietet, soll um
          zusätzliche Funktionen erweitert und an die Anforderungen der
          aktuellen Moodle-Version angepasst werden. </p>

        <p> Diese Arbeit soll einen Beitrag zur Weiterentwicklung von
          Moodle und dessen Ökosystem leisten, indem sie die
          Funktionalität und Kompatibilität eines bestehenden Plugins
          verbessert und erweitert. Zum einen soll das Plugin um die
          Fähigkeit erweitert werden, Fragen in den Formaten
          <a href="https://docs.moodle.org/405/de/GIFT-Format"
             target="_blank" rel="noopener noreferrer" >GIFT</a>
          und <a href="https://docs.moodle.org/405/en/Aiken_Format"
                 target="_blank" rel="noopener noreferrer">Aiken</a> zu
          importieren und zu exportieren. Dies ermöglicht es
          Multiple-Choice-Fragen einfach mit einem Texteditor zu
          erstellte und diese dann anschließend in Moodle zu
          importieren.  Zum anderen soll das Plugin
          gegebenenfalls so angepasst werden, dass es vollständig
          kompatibel mit der aktuellen Version von Moodle
          ist. Dies beinhaltet die Überprüfung und Aktualisierung
          des Codes, um sicherzustellen, dass alle Funktionen
          reibungslos und effizient arbeiten.
        </p>


        <!-- <h4>Editor für SAVE.DAT-Dateien</h4> -->
        <!-- <p>Bei SAVE.DAT handelt es sich um ein Dateiformat, welches -->
          <!--   bei den Computerspielen Fallout und Fallout 2 zur Anwendung -->
          <!--   kommt, um Spielstände zu sichern. Im Rahmen der -->
          <!--   Abschlussarbeit soll eine C/C++- oder Rust-Anwendung für -->
          <!--   Linux geschrieben werden, bei der alle relevanten -->
          <!--   Informationen einer SAVE.DAT-Datei menschenlesbar ausgegeben -->
          <!--   und editiert werden können. Die Anwendung soll dabei nur -->
          <!--   Bibliotheken verwenden, die auch Teil der Debian GNU/Linux -->
          <!--   Distribution sind. Bei dieser Arbeit bietet sich ein CLI-, -->
          <!--   GUI- oder ncurses-basiertes Nutzerinterface an. Mehr zu dem -->
          <!--   SAVE.DAT-Dateiformat finden -->
          <!--   Sie <a href="https://fallout.wiki/wiki/SAVE.DAT_File_Format" -->
          <!--          target="_blank" rel="noopener noreferrer">hier</a> -->
          <!--   und <a href="https://falloutmods.fandom.com/wiki/SAVE.DAT_File_Format" -->
          <!--          target="_blank" rel="noopener noreferrer">hier</a>. -->
          <!-- </p> -->

        <h4>Visualisierung von Operationen auf einem  AVL-Baum</h4>
        <p>
          Im Rahmen dieser Abschlussarbeit soll eine Anwendung erstellt
          werden, welche die Einfüge- und Löschoperation bei einem 
          <a href="https://de.wikipedia.org/wiki/AVL-Baum" target="_blank"
             rel="noopener noreferrer"> AVL-Baum</a>
          visualisiert. Im Fokus stehen hier die Einfach- und
          Doppelrotationen. Die Anwendung soll noch die weiteren Anforderungen erfüllen
          <ul class="list">
            <li> Exportieren eines AVL-Baums in einen menschenlesbare Form.</li>
            <li> Importieren eines AVL-Baums aus einer Datei. </li>
            <li> Anzeige der einzelnen AVL-Werte. </li>
            <li> Konvertierung eines beliebigen binären Suchbaum in einen AVL-Baum.</li>
            <li> Animierte Einfach- und Doppelrotationen. </li>
            <li> Unterstützung von Bäumen mit bis zu 63 Knoten. </li>
            <li> (OPTIONAL) Gamification Aspekte. </li>
          </ul>
          
          
          <h4>Visualisierung der Tiefensuche</h4>
        <p>
          Im Rahmen dieser Abschlussarbeit soll eine Anwendung
          erstellt werden, welche die
          <a href="https://de.wikipedia.org/wiki/Tiefensuche"
             target="_blank" rel="noopener noreferrer">
            Tiefensuche</a> visualisiert. Und zwar soll mittels der
          Tiefensuche ein Ausgang aus einem Labyrinth gefunden
          werden. Folgende Features sollen implementiert werden:
        </p>
        <ul class="list">
          <li>
            Editierend von Labyrinthen
          </li>
          <li>
            Speichern und Laden von Labyrinthen.
          </li>
          <li>
            Der Startpunkt und das Ziel/Ausgang soll frei wählbar sein.
          </li>
          <li>
            GNU/Linux Unterstützung.
          </li>
        </ul>


        <h4>Anwendung zur Veranschaulichung von Sortierverfahren</h4>
        <p>
          Im Rahmen dieser Abschlussarbeit soll ein Anwendung für
          die Lehre implementiert werden. Ziel der Anwendung ist es zum
          einen den NutzerInnen Sortierverfahren verständlich zu
          erläutern und zum anderen durch Test herausfinden, ob diese
          auch verstanden wurden. Insgesamt soll die Anwendung die
          folgenden fünf Sortierverfahren abdecken.
        </p>
        <ol>
          <li> BubbleSort    </li>
          <li> InsertionSort </li>
          <li> MergeSort     </li>
          <li> HeapSort      </li>
        </ol>
        <p>
          Die einzelnen Implementierungen sollen dabei den Definitionen
          aus meinen Lehrmaterialien zu dem Modul <q> Algorithmen und
            Datenstrukturen </q> entsprechen. Daher sind sie
          eigenständig zu implementieren.

          
          Die Anwendung kann beispielsweise über einen Erklär- und
          einen Testmodus verfügen. Bei dem Erklärmodus können die
          Sortierverfahren durch Animationen (spielerisch)
          näher gebracht werden.
          
          In dem Testmodus sollen unsortiertes Array mithilfe eines
          angegeben Sortierverfahrens sortiert werden. Dabei soll die
          NutzerInnen natürlich Feedback bekommen, ob Sie alles richtig
          gemacht haben und falls nicht soll veranschaulicht werden, wo
          es hakte.
        </p>

        <p>
          Ein wichtiger Aspekt dieser Arbeit ist selbstverständlich
          die Usability der Anwendung. Gerne kann auch die Motivation
          zur Nutzung der Anwendung mithilfe von Gamification Aspekten
          optimiert werden.

          Ich kann mir gut vorstellen, diese Anwendung in eine Art
          Spiel zu verpacken. Ein Beispiel für ein Spiel durch das
          die NutzerInnen Assembler lernen
          ist <a href="https://en.wikipedia.org/wiki/Human_Resource_Machine"
                 target="_blank" rel="noopener noreferrer"> Human Resource
            Machine </a>. Wie Sie sehen ist bei dieser Arbeit der
          Kreativität keine Grenzen gesetzt.
        </p>


        <h4>Generierung von UML-Diagrammen</h4>
        <p>
          Im Rahmen dieser Abschlussarbeit soll eine Bibliothek
          erstellt werden die aus C++ oder Java-Klassen
          einliest und daraus ein UML-Klassendiagramm erstellt.
        </p>
        <p>
          Aufgabe ist es also das parsen von Quelldateien und die
          Generierung von Vektorgraphiken welche sich möglichst
          einfach in ein LaTeX Dokument, wie beispielsweise eine
          Abschlussarbeit, integrieren lassen sollen. Es ist wäre
          wünschenswert, falls die LaTeX-Ausgabe kompatibel zu zu dem
          CTAN-Paket <a href="https://ctan.org/pkg/uml"
                        target="_blank" rel="noopener noreferrer"> UML </a> ist.
        </p>
        
        <h4>Vergleich des Speicherverbrauchs eigener Implementierungen von Echo-Servern bei parallelen Verbindungen</h4>
        <p>Die Masterarbeit widmet sich einem detaillierten Vergleich des
          Speicherverbrauchs von selbst erstellten Echo-Servern, die in
          verschiedenen Programmiersprachen und Frameworks implementiert sind,
          bei unterschiedlichen parallelen Verbindungen. Ein Echo-Server ist
          ein einfacher Server, der die empfangenen Daten zurücksendet, ohne
          diese zu verarbeiten. In dieser Arbeit werden eigene
          Implementierungen der Echo-Server in den folgenden
          Programmiersprachen und Frameworks erstellt und verglichen:</p>
        <ul>
          <li>Spring Framework</li>
          <li>Express Framework</li>
          <li>Django Framework</li>
          <li>Rails Framework</li>
          <li>Laravel Framework</li>
          <li>\ldots</li>
        </ul>
        <p>Das Hauptziel der Arbeit ist es, den Speicherverbrauch jeder
          eigenen Implementierung bei 10, 100, 1.000 und 10.000 parallelen
          Verbindungen zu analysieren und zu vergleichen. Diese
          unterschiedlichen Lastszenarien ermöglichen es, die Skalierbarkeit
          und Effizienz der eigenen Echo-Server unter verschiedenen
          Belastungen zu bewerten.</p>

        <p>Die Masterarbeit wird eine umfangreiche Umsetzung der eigenen
          Echo-Server-Implementierungen beinhalten. Dabei werden spezifische
          Testumgebungen geschaffen, um die parallelen Verbindungen zu
          simulieren und den Speicherverbrauch präzise zu messen.</p>

        <p>Die erzielten Ergebnisse werden sorgfältig dokumentiert und in
          einer übersichtlichen Form präsentiert. Die gewonnenen Erkenntnisse
          werden wertvolle Informationen für die Entwicklergemeinschaft
          liefern, um die optimale Implementierung für
          Echo-Server-Anwendungen zu wählen. Die Arbeit wird zudem als
          wertvolle Grundlage dienen, um die Leistung und Skalierbarkeit von
          Webanwendungen zu verbessern und fundierte Entscheidungen
          hinsichtlich der Auswahl des geeigneten Frameworks zu treffen.</p>

        <p>Diese Masterarbeit wird einen tiefgreifenden Einblick in den
          Speicherverbrauch von selbst erstellten Echo-Servern bei parallelen
          Verbindungen ermöglichen und einen bedeutsamen Beitrag zur
          effizienten Entwicklung von skalierbaren Webanwendungen
          leisten.</p>

        <h4>Graphische Anwendung zum Erstellen und Bearbeiten von
          TikZ-Diagrammen</h4>
        <p> Das Textsatzsystems Tex wurde von dem Turing Award Winner
          Donald E. Knuth von 1977 bis 1986 entwickelt. In den 1980er
          hat der Turing Award Winner Leslie Lamport darauf aufbauend
          die Entwicklung von LaTeX begonnen. Primär wurde LaTeX mit
          dem Ziel entwickelt um wissenschaftliche Arbeiten,
          technische Reports und Sachbücher zu Verfassen. Ähnlich zu
          HTML lässt sich mit LaTeX die Strukturen des zu erstellenden
          Dokuments beschreiben.  Inzwischen gibt es unzählige
          Schriftsätze für LaTeX mit denen sich unter anderem 
          <a href="https://ctan.org/pkg/beamer"  target="_blank"
             rel="noopener noreferrer"> Foliensätze</a>,
          <a href="https://ctan.org/pkg/uml" target="_blank" rel="noopener noreferrer"> UML-Diagramme</a>,
          <a href="https://ctan.org/pkg/musictex" target="_blank" rel="noopener noreferrer">  Notentexte (Partituren)</a>
          oder <a href="https://ctan.org/pkg/pgf">Vektorgrafiken </a> aufschreiben lassen.
        </p>
        <p>
          Im Rahmen dieser Abschlussarbeit soll ein Programm
          implementiert werden mit dem sich einfache Blockdiagramme,
          welche die Funktionsweise von Funktionen oder Algorithmen
          beschreiben, erstellen lassen. Die Vektorgraphiken sollen
          als PGF/Tikz-Graphik gespeichert oder exportiert werden
          können.
          
          Bei <a href="https://de.wikipedia.org/wiki/PGF/TikZ"
                 target="_blank" rel="noopener noreferrer"> PGF/TikZ </a>
          handelt es sich um eine Sprache zum Erstellen von
          Vektorgraphiken welche dann einfach in ein LaTeX Dokumente
          eingefügt werden können. Schauen Sie sich die
          Beispielgallerie unter
          <a href="https://texample.net/tikz/examples/"
             target="_blank" rel="noopener noreferrer">
            https://texample.net/tikz/examples/ </a> an. Dadurch
          erhalten Sie einen Eindruck welche Vielzahl an
          unterschiedlichen PGF/TikZ-Graphiken sich mit Hilfe von
          LaTeX Quellcode erstellen lassen.
        </p>
        <p>
          Der Fokus dieser Arbeit soll auf dem Softwaredesign und die
          einfacher Erweiterbarkeit liegen und noch auf dem Umfang
          der Funktionalität. Die Anwendung soll es ermöglichen
          Rechtecke und Kreise zu malen und diese mit gerichteten
          oder ungerichteten Linien zu Verbinden. Weiterhin soll eine
          Beschriftung der einzelnen Objekte möglich sein.
        </p>


        <h4>Transparente Verschlüsselung von Ordnern </h4>
        <p>
          Bei dieser Abschlussarbeit soll unter Linux eine Lösung
          entwickelt werden, bei dem Ordner für Benutzer transparent
          verschlüsselt werden. Die Ordner müssen also transparent in
          das Dateisystem integriert werden. Der technisch unbedarfte
          Nutzer sollte keinen Unterschied zwischen einem regulären
          und einem verschlüsselten Verzeichnis feststellen. Dies
          schließt eine transparente Einbindung der verschlüsselten
          Ordner in das Dateisystem mit ein.
        </p>
        <ul class="list">
          <li>
            Die Inhalte der Ordner sollen mit Hilfe eines modernen und
            robusten AE-Schemas verschlüsselt werden. Geeignete
            Kandidaten wären beispielsweise
            <a href="https://github.com/medsec/riv" target="_blank"
               rel="noopener noreferrer">RIV</a> oder
            <a href="https://github.com/medsec/poet" target="_blank" rel="noopener noreferrer">POET</a>
          </li>
          <li>
            Der geheime Schlüssel soll dabei aus dem Login-Passwort mit
            einer modernen Key-Derivation-Funktion wie
            beispielsweise <a href="https://github.com/Tarsnap/scrypt"
                              target="_blank" rel="noopener noreferrer">scrypt</a>
            oder <a href="https://github.com/medsec/catena"
                    target="_blank" rel="noopener noreferrer">Catena</a>
            abgeleitet werden.
          </li>
          <li>
            Es wäre wünschenswert wenn die Lösung unter GitHub
            publiziert wird. Weiterhin würde ich mich noch sehr freuen,
            falls die Lösung als deb-Paket bereitgestellt wird.
          </li>
        </ul>



        <h4>Modernes Passwort Hashing</h4>
        <p>
          Bei dieser Abschlussarbeit soll unter Linux eine modernes
          Verfahren zum Hashen von Passwörtern entwickelt werde,
          welches resistent gegen
          <a href="https://de.wikipedia.org/wiki/Grafikprozessor"
             target="_blank" rel="noopener noreferrer">GPU</a> Angriffe
          ist, die Realisierung in Hardware
          (<a href="https://de.wikipedia.org/wiki/Anwendungsspezifische_integrierte_Schaltung"
              target="_blank" rel="noopener noreferrer">ASIC</a>) teuer
          ist und sicher
          gegen <a href="https://de.wikipedia.org/wiki/Seitenkanalattacke"
                   target="_blank" rel="noopener
                                        noreferrer">Seitenkanalangriffe</a> ist. Ein solches
          Verfahren eignet sich nicht nur für den Einsatz auf
          Notebooks, Servern und Desktops sondern auch für den Einsatz
          in der Cloud, bei der mehrere Benutzer Hardware teilen.

          Das neue Verfahren soll dabei auf den Resultaten des
          wissenschaftlichen
          Artikels <a href="https://eprint.iacr.org/2018/944"
                      target="_blank" rel="noopener noreferrer"> <q>
              Data-Independent Memory Hard Functions: New Attacks and
              Stronger Constructions </q></a> von Blocki und anderen in
          das bereits existierende
          Verfahren <a href="https://eprint.iacr.org/2013/525.pdf"
                       target="_blank" rel="noopener noreferrer">Catena</a> von
          Forler und anderen integrieren.
        </p>
        <p>
          Bei der Entwicklung kann dabei auf bereits existierenden
          Sourcecode zurückgegriffen werden.
        </p>


        <h4>Dynamische Deadlock Erkennung </h4>
        <p>
          Bei dieser Abschlussarbeit soll eine Lösung entwickelt
          werden, mit der sich zur Laufzeit Deadlocks innerhalb eines
          Linux-Prozesses entdecken lassen, der PThreads verwendet.
        </p>
        <p>
          Die Lösung soll einen Prozess zur Laufzeit beobachten und
          immer den aktuellen Zustand des Betriebsmittelgraphen
          rendern. Falls es zu einem Deadlock kommt, soll dieser
          visuell hervorgehoben werden. Optional soll es möglich sein,
          einer der beteiligten Threads zu terminieren, um den
          Deadlock aufzulösen.
        </p>
        <p>
          Ein Guter Einstiegspunkt in die Thematik ist die
          wissenschaftliche Veröffentlichung
          <em> Deadlock detection runtime service for Embedded Linux </em>
          von Glatz und anderen.
        </p>
      </div>
    </div>
  </div>
</div>
<footer class="footer legal pure-g">
    <!--<div class="l-box">-->
        <div class="pure-u-md-1-2">
            <p class="align-left">&#x24B8; 2018-2023 Berliner Hochschule für Technik</p>
        </div>
        <div class="pure-u-md-1-2">
          <p class="link-extern align-right">
            <a href="https://www.bht-berlin.de/impressum/"
               target="_blank" rel="noopener noreferrer">
              Impressum/Datenschutz </a></p>
        </div> 
    <!--</div>-->
</footer>
</body>
</html>
